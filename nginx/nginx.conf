# ─────────────────────────────────────────────────────────────────────────────
# Production nginx reverse-proxy configuration for astor applications.
#
# Assumptions:
#   - astor runs on 127.0.0.1:3000  (adjust the upstream block as needed)
#   - TLS is terminated here; astor receives plain HTTP/1.1
#
# On Kubernetes:
#   Replace the upstream address with your Service DNS name:
#       server  astor-service.default.svc.cluster.local:3000;
#   Or use the k8s/ingress.yaml manifest and skip this file entirely.
# ─────────────────────────────────────────────────────────────────────────────

upstream astor_backend {
    server 127.0.0.1:3000;

    # ── Keep-alive connection pool ────────────────────────────────────────────
    #
    # How it works:
    #   nginx workers maintain a pool of idle TCP connections to astor.
    #   Instead of opening a new TCP connection per request (3-way handshake
    #   + kernel overhead), nginx reuses a connection from the pool.
    #   astor loops on the same connection serving requests until nginx closes it.
    #
    # keepalive N
    #   Maximum idle connections kept open per nginx worker process.
    #   Rule of thumb: (expected RPS / nginx worker count) × avg request duration.
    #   Too low  → pool exhausted under load, new TCP connections are opened.
    #   Too high → idle file descriptors wasted; kernel connection tracking grows.
    #   Start with 64 and raise if you see frequent TCP connection churn in logs.
    keepalive 64;

    # keepalive_requests N
    #   Maximum requests served on a single keepalive connection before nginx
    #   closes it and opens a fresh one. Prevents any single connection from
    #   living forever and accumulating kernel state. Default: 1000.
    keepalive_requests 1000;

    # keepalive_timeout Xs
    #   How long an idle connection sits in the pool before nginx closes it.
    #   Match to your traffic pattern: low-traffic services can use a short
    #   timeout to free resources; high-traffic services benefit from longer.
    #   Default: 60s.
    keepalive_timeout 60s;
}

# ── HTTP → HTTPS redirect ─────────────────────────────────────────────────────

server {
    listen      80;
    server_name example.com;
    return 301  https://$host$request_uri;
}

# ── HTTPS server ──────────────────────────────────────────────────────────────

server {
    listen      443 ssl;
    http2       on;
    server_name example.com;

    # ── TLS ──────────────────────────────────────────────────────────────────
    ssl_certificate      /etc/nginx/ssl/cert.pem;
    ssl_certificate_key  /etc/nginx/ssl/key.pem;

    ssl_protocols        TLSv1.2 TLSv1.3;
    ssl_ciphers          HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers off;

    ssl_session_cache    shared:SSL:10m;
    ssl_session_timeout  1d;
    ssl_session_tickets  off;

    # ── Security headers ──────────────────────────────────────────────────────
    # nginx owns these — do not duplicate them in astor.
    add_header Strict-Transport-Security  "max-age=63072000; includeSubDomains; preload" always;
    add_header X-Frame-Options            DENY                                           always;
    add_header X-Content-Type-Options     nosniff                                        always;
    add_header X-XSS-Protection           "1; mode=block"                                always;
    add_header Referrer-Policy            "no-referrer"                                  always;

    # ── Request limits ────────────────────────────────────────────────────────
    # Enforced by nginx before the request reaches astor.
    client_max_body_size    10m;
    client_header_timeout   10s;
    client_body_timeout     30s;
    send_timeout            30s;

    # ── Proxy to astor ──────────────────────────────────────────────────────────
    location / {
        # ── Method allowlist ──────────────────────────────────────────────────
        #
        # nginx does NOT block unknown HTTP methods by default — it forwards
        # everything to the upstream, including garbage like BANANA.
        # limit_except lists the methods you ALLOW; everything else gets 405.
        #
        # This mirrors the Method enum in astor exactly.
        # If you use WebDAV routes, add the relevant methods here:
        #   COPY LOCK MKCALENDAR MKCOL MOVE PROPFIND PROPPATCH REPORT SEARCH UNLOCK
        # If you use Varnish/nginx cache invalidation, add PURGE.
        limit_except GET POST PUT PATCH DELETE OPTIONS HEAD CONNECT TRACE {
            return 405;
        }

        proxy_pass          http://astor_backend;
        proxy_http_version  1.1;

        # Required for keep-alive: clear the default "close" value nginx sets.
        proxy_set_header    Connection         "";

        # Forward the real client IP so astor can log it.
        proxy_set_header    Host               $host;
        proxy_set_header    X-Real-IP          $remote_addr;
        proxy_set_header    X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header    X-Forwarded-Proto  $scheme;

        # Backend timeouts — tune to your slowest endpoint.
        proxy_connect_timeout  5s;
        proxy_send_timeout     60s;
        proxy_read_timeout     60s;

        # REQUIRED: proxy_buffering on (this is the nginx default).
        # With buffering on, nginx buffers the full request body and forwards
        # it to astor with a Content-Length header. astor does not support chunked
        # transfer encoding — setting this to off will break request body reads.
        proxy_buffering     on;
        proxy_buffer_size   4k;
        proxy_buffers       8 4k;
    }

    # ── Health probes ─────────────────────────────────────────────────────────
    # Skip access_log to avoid polluting logs with probe noise.
    location /healthz {
        proxy_pass          http://astor_backend;
        proxy_http_version  1.1;
        proxy_set_header    Connection  "";
        access_log          off;
    }

    location /readyz {
        proxy_pass          http://astor_backend;
        proxy_http_version  1.1;
        proxy_set_header    Connection  "";
        access_log          off;
    }
}
