apiVersion: apps/v1
kind: Deployment
metadata:
  name: tsu-app
  labels:
    app: tsu-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: tsu-app
  template:
    metadata:
      labels:
        app: tsu-app
    spec:
      containers:
        - name: app
          image: your-registry/tsu-app:latest
          ports:
            - name: http
              containerPort: 3000
              protocol: TCP
          env:
            - name: RUST_LOG
              value: "info"

          resources:
            requests:
              cpu: "100m"
              memory: "64Mi"
            limits:
              cpu: "500m"
              memory: "128Mi"

          # ── Liveness probe ────────────────────────────────────────────────
          # If this fails, Kubernetes restarts the pod.
          # Keep it cheap — if your process can answer HTTP it is alive.
          livenessProbe:
            httpGet:
              path: /healthz
              port: http
            initialDelaySeconds: 5   # wait for the process to start
            periodSeconds: 10
            failureThreshold: 3

          # ── Readiness probe ───────────────────────────────────────────────
          # If this fails, the pod is removed from the Service endpoint list
          # (no traffic sent to it) but it is NOT restarted.
          # Use this to signal warm-up or dependency unavailability.
          readinessProbe:
            httpGet:
              path: /readyz
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 3

      # ── Graceful shutdown ─────────────────────────────────────────────────
      # On SIGTERM, tsu stops accepting and drains in-flight requests.
      # This value must be LONGER than your slowest request.
      # After this period Kubernetes sends SIGKILL regardless.
      terminationGracePeriodSeconds: 30
